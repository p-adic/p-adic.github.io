---
layout: project
title: プログラミング言語Qp
excerpt: "プログラミング言語Qpの導入です。"
date: 2020-05-02
project: true
class-name: Qp
tags: [Qp,C++]
---

An English summary is available [here](https://googology.wikia.org/wiki/User_blog:P%E9%80%B2%E5%A4%A7%E5%A5%BD%E3%81%8Dbot/Introduction_to_Programming_Language_Qp).

ここでは***プログラミング言語$$\mathbb{Q}_p$$***の仕様を自然言語ベースで曖昧に導入します。$$\mathbb{Q}_p$$は巨大数の定義を書きやすくするために
1. 通常の数学の流儀に近い構文を採用すること
1. C++コンパイラでコンパイルできること
1. 定義文を日本語と英語に自動翻訳できること

のみを重視して開発中のプログラミング言語です。そのため、実際に実行するためのライブラリを実装するかどうかは未定ですが、どのように実行されるかが厳密に分かるように曖昧さのない日本語に自動翻訳します。仮に実行できるようになったとして、どうせ巨大数の計算は終わらないので最適化処理をする気もあまりありません。

また今後も開発を続けていく予定なので、こちらに記載された仕様は後に変更になる可能性が十分にあります。

{% assign i = 0 %}
{% assign j = 0 %}
# {{ i }}. コード例

構文の説明に入る前に、実際のコードを見てみましょう。

~~~c++
  
  USE( int , x );
  IMP( bool , r , x );
  SPEC( S , x , r );
  USE( S , y );

  USE( bool , b1 );
  USE( bool , b2 );
  
  USE( string , s1 );
  USE( string , s2 );

  IMP( int , g , s1 , s2 );
  SET( g , SYMBOL , STR( \\Gamma ) );
  SET( g , SEPARATOR , SYMBOLISE( g ) + LBIG + LPAREN + LMAT(c) + SPACE , SPACE + YY + SPACE , SPACE + RMAT + RBIG + RPAREN );

  IMP( int , f , s1 , s2 , b1 , y );
  SET( f , SEPARATOR , SYMBOLISE( f ) + SUB + LBRACE , RBRACE + SUP + LBRACE , RBRACE + LPAREN , COMMA , RPAREN );
  
  DEF( f ){

    PUT( b2 , s1 == s2 ) ,
      
      IF( b2 >> ( ( ! b1 && b2 ) || b2 ),

	  IF( ( b1 << ( b2 || b1 ) ) , PUT( x , 1 ) ) ,

	  // ここを通るのはバグ
	  IF( ! ( ( b1 && b1 ) ->* b1 ) , EXIT ) ,

	  IF( b2 , RETURN( x + y ) )
       
	  ) ,

      RETURN( y + g( s2 , s1 + s2 ) )
      
      };

  WRITE( S , JAPANESE , FANDOM , a.txt , TRUNC );
  
  DISPLAY( f );
  WRITE( f , JAPANESE , FANDOM , a.txt , APP );
  
~~~

それぞれの行は以下のような意味を持ちます：
- USEで定義に用いる変数の型と記号を宣言している。
- IMPで定義に用いる演算子の戻り値の型と記号と引数を宣言している。
- SPECで型の部分型を定義している。
- SETとSYMBOLで翻訳時に表示される演算子記号の変更をしている。（オプション）
- SETとSEPARATORで翻訳時に表示される演算子記法（通常の関数記法、ポーランド記法、中置記法、逆ポーランド記法、添字による記法、等）やセパレータには何を用いるかを設定している。（オプション）
- DEFで定義を記述している。
- PUTで引数以外の変数の値を定義している。
- IFで場合分けを行っている。
- EXITで異常終了を記述している。
- RETURNで定義する演算子の戻り値を記述している。
- DISPLAYで宣言の木構造を標準出力している。
- WRITEで定義文の日本語訳をファイルに書き込んでいる。

下の画像は先程のコードを自動翻訳した日本語の文章です。上で説明した意味と整合的な翻訳になっていることが分かると思います。

<div style="background-color:black">
  <div style="padding : 10px">
    <img src="{{ site.img }}/Qp-demo.png">
  </div>
</div>


{% assign i = i | plus: 1 %}
{% assign j = 0 %}
# {{ i }}. 準備

細かい話に入る前に、用語法や記法の説明をします。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 変数の扱い

$$\mathbb{Q}_p$$における変数は、通常のプログラミング言語における変数と違って値の変更が不可能なものです。従って等号は全て「等しい」という関係でのみ使われ、代入による書き換えを表すことはありません。ポインタもありません。これらは通常の数学における変数に似せた仕様です。ただし通常の数学と違って量化子による変数の束縛を明示的に扱いません。とはいえ関数という概念の通常の数学における定義にはもちろん量化子による束縛が行われていますので、量化子が隠れているだけと思って下さい。

また演算子（関数や関係）の引数を含む全ての変数は、最初に宣言を必要とします。更に演算子の引数でない全ての変数は、その演算子の定義文内で最初に参照される際に値を定義される必要があります。これらの仕様は実用的でなく煩わしいかもしれませんが、「動く範囲の不明な変数を使う」とか「未定義の値を使う」といった巨大数の定義でありがちなミスを防ぐための厳格なものです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 関数の扱い

$$\mathbb{Q}_p$$における関数は、通常のプログラミング言語における関数と違って変数の書き換えを行う機能はなく、また必ず戻り値を持つことが想定されています。これらは通常の数学における部分再帰的関数に似せた仕様です。ただし通常の数学と違って単に値を出力するだけでなく、標準出力を行うことも可能です。

また関数の宣言においては引数の指定を必要とします。引数自体も変数であり宣言が必要であるため、これにより関数は宣言の時点で定義域がどんな集合の部分集合であるかが確定します。これらの仕様は実用的でなく煩わしいかもしれませんが、「定義域の不明な関数を使う」とか「定義域外の値を関数に代入する」といった巨大数の定義でありがちなミスを防ぐための厳格なものです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 階数

$$\mathbb{Q}_p$$で許容される文字列全体の集合は再帰的に定義されます。$$\mathbb{Q}_p$$で許容される文字列のいくつかには階数という自然数が定義されており、特定の階数を持つ$$\mathbb{Q}_p$$で許容される文字列の定義にはそれ以上の階数を持つ$$\mathbb{Q}_p$$で許容される文字列は使いません。

また$$\mathbb{Q}_p$$で許容される文字列の階数を集めて有限集合を考えることがありますが、その***上限***とは、その集合が空集合の時は$$0$$のことであり、空集合でない時はその最大値のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 文字列の結合

文字列の列`A`を`,`で結合して得られる文字列をこの記事では`Concatenate(A)`と表します。例えば`A`が空列であれば`Concatenate(A)`は空文字列となります。`A`がただ$$1$$つの成分を持つならば`Concatenate(A)`は`A`の唯一の成分です。`A`がちょうど$$2$$つの成分を持つならば、`A`の第$$1$$成分を`x`と置き第$$2$$成分を`y`と置くと、`Concatenate(A)`は文字列`x,y`となります。

`A`に一切制限がない場合は`Concatenate(A)`から`A`を復元することが出来ないので、「`Concatenate(A)`に対し$$X$$という概念を（`A`を用いて）$$Y$$と定める」のような文は$$X$$の定義を与えません。一方で`A`に十分強い制約（例えばいずれの成分も`,`を含まない等）を課している文脈では`Concatenate(A)`から`A`を復元することが可能になることがあり、そういう場合には「`Concatenate(A)`に対し$$X$$という概念を（`A`を用いて）$$Y$$と定める」のような文で$$X$$を定義することができます。

一般に「$$Z$$に対し、$$B$$を用いて$$X$$を$$Y$$と定める」という文は$$Z$$と$$B$$から$$Y$$が一意に定まりかつ$$Z$$から$$B$$が一意に定まる場合にのみ、$$Z$$のみに依存する概念としての$$X$$の定義を与えます。この記事においてもそれらの条件が満たされている場合にのみ、そのような構文を用いて定義していきます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 文字列の位置関係

構文の説明の中に「～以降の文字列」という言葉遣いが現れますが、これは何となく意味が分かる概念でありながらもかなり曖昧な表現です。何故なら、これは２つの文字列の「位置関係」に関する述語であって２つの文字列そのものに関する述語ではなく、厳密に書こうとすると文字列の分割に関する述語として定義する必要があります。それを（書くのは簡単ですが）読むのは大変になると思うので、ここでは「～以降の文字列」という言葉遣いの厳密な定義はしません。


{% assign i = i | plus: 1 %}
{% assign j = 0 %}
# {{ i }}.構文

$$\mathbb{Q}_p$$で許容される文字列として、以下の分類を説明していきます。
1. 型（type）
    1. 基本型（basic type）
    1. 特殊型（specialised type）
    1. 直積型（direct product type）
    1. 配列型（array type）
1. 宣言（declaration）
    1. USE宣言（USE declaration）
    1. IMP宣言（IMP declaration）
1. 表現（expression）
    1. 定数（constant symbol）
    1. 変数（variable symbol）
    1. 演算子表現（operator expression）
1. 演算子（operator symbol）
    1. 関数（function symbol）
    1. 関係（relation symbol）
1. 可変長引数演算子（variadic operator symbol）
    1. 可変長引数関数（variadic function symbol）
    1. 可変長引数関係（variadic relation symbol）
1. 命令行（line）
    1. PUT文（PUT sentence）
    1. PRINT文（PRINT sentence）
    1. IF文（IF sentence）
    1. EXIT文（EXIT sentence）
    1. RETURN文（RETURN sentence）
1. 定義文（definition）
    1. SPEC構成（SPEC construction）
    1. PROD構成（PROD construction）
    1. DEF文（DEF sentence）
1. 補助構文（guide syntax）
    1. シンボル設定（symbol setting）
    1. セパレータ（separator）
    1. セパレータリスト（separator list）
    1. セパレータ設定（separator setting）
    1. 全域性設定（totality setting）
    1. 宣言標準出力（declaration stdout）
    1. 翻訳出力（translation output）

これらの分類には重複があり、例えば定数は表現となり、表現は表現リストとなります。またこれらに分類される全ての文字列が$$\mathbb{Q}_p$$で扱えるということではなく、この分類に適合することはあくまでコンパイルを通るための条件です。実行時に要請される追加の条件は「規格」の章で説明します。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 基本型

***基本型***または***basic type***とは、以下の４種類の文字列のことです；
1. 文字列`void`
1. 文字列`int`
1. 文字列`string`
1. 文字列`bool`

また基本型`T`に対し、***`T`の階数***という概念を$$0$$と定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. SPEC構成

自然数$$R$$に対し、階数$$R+1$$の***SPEC構成***または***SPEC construction***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列`T`と$$R = \max \{R_1,R_2\}$$を満たす自然数$$R_1$$と$$R_2$$と階数$$R_1$$の変数`x`と階数$$R_2$$の関係`r`を用いて`SPEC(T,x,r)`と表される文字列のことです。`SPEC(T,x,r);`以降の文字列において、***`T`はSPEC構成されている***と言い、***Tの階数***という概念を$$R+1$$として定めます。SPEC構成されている文字列をSPEC構成、PROD構成、USE宣言、IMP宣言することは出来ません。特に特殊型`T`をSPEC構成するSPEC構成は一意となるため、それを***`T`の定義文***と呼びます。（`T`を`r`を満たす`x`全体の型としてspecialisationしたい時に`SPEC(T,x,r);`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 特殊型

***特殊型***または***specialised type***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列であってSPEC構成されているもののことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. PROD構成

自然数$$R$$に対し、階数$$R+1$$の***PROD構成***または***PROD construction***とは、階数$$R$$を上限に持つ空文字列でない型リスト`Ts`を用いて`PROD(Ts)`と表される文字列のことです。`PROD(T,Ts);`以降の文字列において、***`T`はPROD構成されている***と言い、***Tの階数***という概念を$$R+1$$として定めます。PROD構成されている文字列をSPEC構成、PROD構成、USE宣言、IMP宣言することは出来ません。特に特殊型`T`をPROD構成するPROD構成は一意となるため、それを***`T`の定義文***と呼びます。（`T`を`Ts`のdirect producの元全体の型として構成したい時に`PROD(T,Ts);`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 直積型

自然数$$R$$に対し、階数$$R+1$$の***直積型***または***direct product type***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列であってPROD構成されているもののことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 配列型

自然数$$R$$に対し、階数$$R+1$$の***配列型***または***array type***とは、階数$$R$$の型`T`を用いて`ARRAY(T)`と表される文字列のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 型

***型***または***type***とは、以下の２種類の文字列のことです：
1. 基本型
1. 特殊型
1. 直積型
1. 配列型
大雑把には型は命令文や表現の属性の１つです。例えば`int`は表現が整数に関係するという属性を表し、`string`は表現が文字列に関係するという属性を表し、`bool`は表現が条件に関係するという属性を表すと考えてください。ただし型がこの２種類しかないという制約は暫定的なもので、今後「～の配列」とか「～の木」といった性質に関係するという属性を表す型を定義する方法を導入していきます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 型リスト

自然数$$R$$に対し、階数$$R$$を上限に持つ***型リスト***または***type list***とは、$$0$$個以上の型の列`AT`であって階数の上限が$$R$$であるものを用いて`Concatenate(AT)`と表せる文字列のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 定数

***定数***または***constant symbol***とは、以下の３種類の文字列のことです；
1. 整数の符号付き十進法表記
1. 文字列`s`であってエスケープされていない`"`や`'`を含まないものを用いて`STR( s )`と表される文字列
1. 文字列`true`および文字列`false`

また定数`c`に対し、***`c`の型***という概念を上記の場合分けにおいてそれぞれ`int`、`string`、`bool`と定め、***cの階数***という概念を$$0$$と定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. USE宣言

自然数$$R$$に対し、階数$$R+1$$の***USE宣言***または***USE declaration***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列`x`と`void`でない階数$$R$$の型`T`を用いて`USE(T,x);`と表される文字列のことです。`USE(T,x);`以降の文字列において、***`x`はUSE宣言されている***と言い、また***`x`の型***という概念を`T`と定め、***`x`の階数***という概念を$$R+1$$と定めます。USE宣言されている文字列をSPEC構成、PROD構成、USE宣言、IMP宣言することは出来ません。（`x`を`T`型の変数としてuseしたい時に`USE(T,x);`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 変数

***変数***または***variable symbol***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列であってUSE宣言されているもののことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 変数リスト

自然数$$R$$に対し、階数$$R$$を上限に持つ***変数リスト***または***variable symbol list***とは、$$0$$個以上の変数の列`Ax`であって階数の上限が$$R$$であるものを用いて`Concatenate(Ax)`と表せる文字列のことです。***`Concatenate(Ax)`の成分***という概念を`Ax`の成分として定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 可変長変数リスト

自然数$$R$$に対し、階数$$R+1$$の***可変長変数リスト***または***variadic variable symbol list***とは、$$R = \max \{R_1,R_2\}$$を満たす自然数$$R_1$$と$$R_2$$と階数$$R_1$$を上限に持つ変数リスト`x`と階数$$R_2$$の型$$V$$を用いて`x,LDOTS(V)`と表される文字列のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. IMP宣言

自然数$$R$$に対し、階数$$R+1$$の***IMP宣言***または***IMP declaration***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列`f`と$$R = \max \{R_1,R_2\}$$を満たす自然数$$R_1$$と$$R_2$$と`void`でない階数$$R_1$$の型`T`と階数$$R_2$$を上限に持つ変数リストまたは可変長変数リストである文字列`x`を用いて`IMP(T,f,x);`と表される文字列のことです。`IMP(T,f,x);`以降の文字列において、***`f`はIMP宣言されている***と言い、***`f`の戻り値の型***という概念を`T`として定め、***`f`の引数***という概念を`x`として定め、***`f`の階数***という概念を$$R+1$$として定めます。IMP宣言されている文字列をSPEC構成、PROD構成、USE宣言、IMP宣言することは出来ません。（`f`を戻り値が`T`型で引数が`x`である演算子としてimportしたい時に`IMP(T,f,x);`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 宣言

***宣言***または***declaration***とは、以下の２種類の文字列のことです；
1. USE宣言
1. IMP宣言


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 演算子

***演算子***または***operator symbol***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列であってIMP宣言されているもののうち、引数が変数リストであるもののことです。

演算子`f`に対し、`f`の引数の型リストが`A`で`f`の戻り値の型が`R`の時、***`f`の高階型***という概念を`(A)->R`と定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 関数

***関数***または***function symbol***とは、戻り値の型が`bool`でない演算子のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 関係

***関係***または***relation symbol***とは、戻り値の型が`bool`である演算子のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 可変長引数演算子

***可変長引数演算子***または***variadic operator symbol***とは、アルファベットと`_`のみからなる長さ$$1$$以上の文字列であってIMP宣言されているもののうち、引数が可変長変数リストであるもののことです。

可変長引数演算子`f`に対し、`f`の引数の型リストが`A`で`f`の引数の可変長部の型が`V`で`f`の戻り値の型が`R`の時、***`f`の高階型***という概念を`(A,LDOTS(V))->R`と定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 可変長引数関数

***可変長引数関数***または***variadic function symbol***とは、戻り値の型が`bool`でない可変長引数演算子のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 可変長引数関係

***可変長引数関係***または***variadic relation symbol***とは、戻り値の型が`bool`である可変長引数演算子のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 演算子表現

自然数$$R$$に対し、階数$$R+1$$の***演算子表現***または***operator expression***とは、$$R = \max \{R_1,R_2\}$$を満たす自然数$$R_1$$と$$R_2$$と以下の３条件のいずれかを満たす文字列`f`と`a`を用いて`f(a)`と表される文字列のことで、***`f(a)`の型***という概念を`f`の戻り値の型として定め、***`f(a)`の階数***という概念を$$R+1$$と定めます：
1. `f`は階数$$R_1$$の演算子であり、`a`は階数$$R_2$$を上限に持つ表現リストであり、かつ`a`の型リストと`f`の引数の型リストが等しい。
1. `f`は階数$$R_1$$の可変長引数演算子であり、`a`は階数$$R_2$$を上限に持つ表現リスト`a`であり、`a`の型リストが`x`の型リスト`Ts`と全ての成分が`f`の引数の可変長部の型である列`Vs`を用いて`Ts,Concatenate(Vs)`と表せる。
1. `f`は階数$$R_1$$の可変長引数演算子であり、`a`は階数$$R_2$$を上限に持つ可変長表現リスト`a`であり、`a`の型リストが`x`の型リスト`Ts`と全ての成分が`f`の引数の可変長部の型である列`Vs`を用いて`Ts,Concatenate(Vs)`と表せ、`a`の可変長部の型が`f`の引数の可変長部の型と等しい。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 表現

***表現***または***expression***とは、定数または変数または演算子表現である文字列のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 表現リスト

自然数$$R$$に対し、階数$$R$$を上限に持つ***表現リスト***または***expression list***とは、$$0$$個以上の表現の列`Ae`であって階数の上限が$$R$$であるものを用いて`Concatenate(Ae)`と表せる文字列のことです。***`Concatenate(Ae)`の型リスト***という概念を`s`の成分である表現の型の列`AT`を用いて`Concatenate(AT)`と表せる文字列として定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 可変長表現リスト

自然数$$R$$に対し、階数$$R+1$$を上限に持つ***可変長表現リスト***または***variadic expression list***とは、$$R = \max \{R_1,R_2\}$$を満たす自然数$$R_1$$と$$R_2$$と階数$$R_1$$を上限に持つ表現リスト`a`と階数$$R_2$$の型`V`を用いて`a,LDOTS(V)`と表せる文字列のことです。***`a,LDOTS(V)`の型リスト***という概念を`a`の型リストとして定め、***a,LDOTS(V)の可変長部の型***という概念を`V`と定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. PUT文

***PUT文***または***PUT sentence***とは、変数`x`と表現`e`を用いて`PUT(x,e)`と表される文字列のことで、***`PUT(x,e)`の型***という概念を`void`として定めます。このような文を***`x`のPUT文***と呼びます。（USE宣言以降で初出である変数`x`を`e`の糖衣構文としてputしたい時に`PUT(x,e)`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. PRINT文

***PRINT文***または***PRINT sentence***とは、表現リスト`ae`を用いて`PRINT(ae)`と表される文字列のことで、***`PRINT(ae)`の型***という概念を`void`として定めます。（`ae`の成分を標準出力したい時に`PRINT(ae)`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. EXIT文

***EXIT文***または***EXIT sentence***とは、文字列`EXIT`のことで、***`EXIT`の型***という概念を`void`として定めます。（DEF文において処理を異常終了させたい時に`EXIT`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. RETURN文

***RETURN文***または***RETURN sentence***とは、表現`e`を用いて`RETURN(e)`と表される文字列のことで、***`RETURN(e)`の型***という概念を`e`の型として定めます。（DEF文において`e`を出力したい時に`RETURN(e)`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 命令行

命令行、命令行リストおよびIF文という概念をという概念を以下のように同時に再帰的に定義します：
1. ***命令行***または***line***とは、以下の５種類の文字列のことです：
    1. PUT文
    1. PRINT文
    1. IF文
    1. EXIT文
    1. RETURN文
1. ***命令行リスト***または***line list***とは、以下の２条件を満たす$$1$$個以上の命令行の列`AL`と型`T`を用いて`Concatenate(AL)`と表せる文字列のことで、***`Concatenate(AL)`の型***という概念を`T`として定めます。
    1. `AL`の成分である命令行の型は`T`または`void`である。
    1. `AL`は`T`型の命令行を少なくとも$$1$$個成分に持つ。
1. ***IF文***または***IF sentence***とは、以下の２条件を満たす`bool`型の表現`b`と命令行リスト`aL`を用いて`IF(b,aL)`と表される文字列のことで、***`IF(b,aL)`の型***という概念を`aL`の型として定めます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. DEF文

***DEF文***または***DEF sentence***とは、演算子`f`と命令行リスト`aL`であって`f`の戻り値の型と`aL`の型は等しいものを用いて`DEF(f){aL}`と表される文字列のことで、***`DEF(f){aL}`の型***という概念を`aL`の型として定め、***`DEF(f){aL}`の定める演算子***という概念を`f`として定めます。`DEF(f){aL};`以降の文字列において、***`f`は実装されている***と言います。実装されている演算子を実装することはできません。特に演算子`f`を実装するDEF文は一意となるため、それを***`f`の定義文***と呼びます。

ちなみにDEF文内に`;`が現れるうるのは`string`型の定数内のみです。どこかに`;`を書くべきかどうか迷ったら、それがDEF文の内側か外側かで判断しましょう。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 定義文

***定義文***または***definition***とは、以下の２種類の文字列のことです：
1. SPEC構成
1. PROD構成
1. DEF文


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. シンボル設定

***シンボル設定***または***symbol setting***とは、以下の２種類の文字列のことです：
1. 変数または演算子である文字列`x`とコンマを含まない文字列`s`を用いて`SET(x,SYMBOL,s);`と表される文字列。（翻訳時に`x`をエスケープされた`s`のMathJaxでの表示に変更して出力したい時に`SET(x,SYMBOL,s);`して下さい）
1. 文字列`s`を用いて`SET(x,SYMBOL,PLAIN(s));`と表される文字列。（翻訳時に変数または演算子である文字列`x`をエスケープされた`s`のプレインテキスト化に変更して出力したい時に`SET(x,SYMBOL,PLAIN(s));`して下さい）
1. 変数または演算子である文字列`x`を用いて`ROMANISE(x);`と表される文字列。（翻訳時に`x`をプレインテキスト化して出力したい時にDEF文より前に`ROMANISE(x);`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. セパレータ

***セパレータ***または***separator***とは、以下のように再帰的に定義される文字列の属性です：
1. 表現または演算子`x`に対し、文字列`SYMBOLISE(x)`（記号`x`）はセパレータである。
1. 文字列`SPACE`（無視される半角スペース）はセパレータである。
1. 文字列`VSPACE`（無視されない半角スペース）はセパレータである。
1. 文字列`SUB`（下付き指示）はセパレータである。
1. 文字列`SUP`（上付き指示）はセパレータである。
1. 文字列`LPAREN`（左カッコ）はセパレータである。
1. 文字列`RPAREN`（右カッコ）はセパレータである。
1. 文字列`LBRACE`（左中カッコ）はセパレータである。
1. 文字列`RBRACE`（右中カッコ）はセパレータである。
1. 文字列`LBRACK`（左四角カッコ）はセパレータである。
1. 文字列`RBRACK`（右四角カッコ）はセパレータである。
1. 文字列`LANGLE`（左三角カッコ）はセパレータである。
1. 文字列`RANGLE`（右三角カッコ）はセパレータである。
1. 文字列`VERT`（縦線）はセパレータである。
1. 文字列`VVERT`（二重縦線）はセパレータである。
1. 文字列`FRAC`（分数用の横線）はセパレータである。
1. 文字列`LBIG`（左カッコ等の拡大指示）はセパレータである。
1. 文字列`MBIG`（カッコ内の縦線等の拡大指示）はセパレータである。
1. 文字列`RBIG`（右カッコ等の拡大指示）はセパレータである。
1. 文字列`PERIOD`（ピリオド）はセパレータである。
1. 文字列`COMMA`（コンマ）はセパレータである。
1. 文字列`COLON`（コロン）はセパレータである。
1. 文字列`SCOLON`（セミコロン）はセパレータである。
1. 文字列`ATMARK`（アットマーク）はセパレータである。
1. $$1$$個以上の文字`l`, `c` , `r` , `|`のみからなる文字列`s`に対し、文字列`LMAT(s)`（行列開始位置）はセパレータである。
1. 文字列`RMAT`（行列終端位置）はセパレータである。
1. 文字列`ET`（列区切り位置）はセパレータである。
1. 文字列`YY`（行区切り位置）はセパレータである。
1. 文字列`HLINE`（行区切り用の横線）はセパレータである。
1. 文字列`LVEC`（ベクトル開始位置）はセパレータである。
1. 文字列`RVEC`（ベクトル終端位置）はセパレータである。
1. 文字列`X`と`Y`がセパレータならば、それらを`+`で結合した文字列はセパレータである。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. セパレータリスト

***セパレータリスト***または***separator list***とは、$$1$$個以上のセパレータの列`As`を用いて`Concatenate(As)`と表せる文字列のことです。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. セパレータ設定

***セパレータ設定***または***separator setting***とは、演算子`f`とセパレータリスト`as`を用いて`SET(f,SEPARATOR,as);`と表せる文字列のことです。（演算子のセパレータを設定したい時にDEF文より前に`SET(f,SEPARATOR,as);`して下さい。）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 全域性

***全域性***または***totality***とは、以下の３種類の文字列のことです。
- `PARTIAL`
- `TOTAL`
- `PRIMITIVE`


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 全域性設定

***全域性設定***または***totality setting***とは、演算子`f`と全域性`c`を用いて`SET(f,TOTALITY,c);`と表せる文字列のことです。（演算子`f`の定義文を翻訳出力する際に、部分関数であることを明記したければ`SET(f,TOTALITY,PARTIAL);`をし、全域関数であることを明記したければ`SET(f,TOTALITY,TOTAL);`をし、原始再帰関数であることを明記したければ`SET(f,TOTALITY,PRIMITIVE);`をして下さい）

この機能はあくまで翻訳出力時の出力内容に影響を与えるためだけのもので、計算可能性設定に反するような定義文を書いてしまったとしてもコンパイルエラーにはなりません。特に、全域性を主張させることは出来ても実際に全域かどうか（無限ループを生じさせないかどうか）はコンパイルによって判定することは出来ません。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 宣言標準出力

***宣言標準出力***または***declaration stdout***とは、型または表現または演算子である文字列`s`を用いて`DISPLAY(s);`と表せる文字列のことです。（`s`の宣言の木構造を標準出力したい時に`DISPLAY(s);`して下さい）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 翻訳出力

***翻訳出力***または***translation output***とは、型またはDEF文の定める演算子である文字列`s`とコンマを含まない文字列`L`と`S`と`F`と`M`を用いて`WRITE(s,L,S,F,M);`と表せる文字列のことです。（`s`の定義文の`L`語訳を`S`仕様でカレントディレクトリからの相対パスが`F`のファイルにオープンモード`M`で書き込みたい時に`WRITE(s,L,S,F,M);`して下さい）



{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 補助構文

***補助構文***または***guide syntax***とは、以下の４種類の文字列のことです：
1. シンボル設定
1. セパレータ
1. セパレータリスト
1. セパレータ設定
1. 翻訳出力

{% assign i = i | plus: 1 %}
{% assign j = 0 %}
# {{ i }}.コンパイル

$$\mathbb{Q}_p$$で許容される文字列`C`に対して、[こちらのライブラリ](https://github.com/p-adic/cpp)を適切に使用すると`int main(){C; return 0;}`というコードがC++コンパイラでコンパイルすることが出来ます。このコードが正常にコンパイルできることは`C`が$$\mathbb{Q}_p$$で許容される文字列であるための必要条件であって十分条件ではありません。例えば`C`が`int x = 0`という文字列の場合、`C`は$$\mathbb{Q}_p$$で許容される文字列ではありませんが`int main(){C; return 0;}`というコードは正常にコンパイルすることができます。

C++でも$$\mathbb{Q}_p$$でも許容されない文字列の多くはコンパイルエラーとなりますので、$$\mathbb{Q}_p$$のコードのつもりで書いた文字列が$$\mathbb{Q}_p$$で許容されるか否かの判定には十分機能すると思います。

ライブラリを導入するのが面倒という人は[管理人](https://twitter.com/non_archimedean)にコードを渡して下さればコンパイルエラーの有無を返答致します。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 予約語

USE等の上記で説明されている文字列以外に、予め機能が定義されている文字列が存在します。例えばC++の予約語は$$\mathbb{Q}_p$$でも予約語となります。そうしないと、C++コンパイラで正常にコンパイル出来ないからです。C++の予約語以外の$$\mathbb{Q}_p$$の予約語は列挙するのが面倒なので、気にしないで下さい。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 糖衣構文

C++コンパイラに内蔵されているプリプロセッサを使うので、`#define`により糖衣構文を導入することが出来ます。従ってC++の定義済みマクロは定義せずに用いることが出来ますが、一方でC++の定義済みマクロと衝突するマクロを定義することは出来ません。


{% assign j = j | plus: 1 %}
{% assign k = 0 %}
## {{ i }}.{{ j }} 定義済み演算子

\(\mathbb{Q}_p\)にはいくつかの演算子が最初から定義されており、IMP宣言せずに用いることが出来ます。

{% assign k = k | plus: 1 %}
## {{ i }}.{{ j }}.{{ k }} 糖衣構文付き演算子

加法や不等号や論理和などの基本的な以下の演算子はユーザー定義の演算子と異なり、中置記法等の特殊な記法を糖衣構文に持ちます：
- 加算演算子`PLUS`（可変長引数、中置記法`+`）
- 乗算演算子`TIMES`（可変長引数、中置記法`*`） 
- 減算演算子`MINUS`（引数$$2$$、中置記法`-`） 
- 除算演算子`SLASH`（引数$$2$$、中置記法`/`） 
- 剰余演算子`MOD`（引数$$2$$、中置記法`%`）
- 冪演算子`POWER`（引数$$2$$、中置記法`^`）
- 否定演算子`NEG`（引数$$1$$、ポーランド記法`!`）
- 論理積演算子`LAND`（可変長引数、中置記法`&&`） 
- 論理和演算子`LOR`（可変長引数、中置記法`||`） 
- 含意演算子`TO`（引数$$2$$、中置記法`>>`と`->*`）
- 逆含意演算子`OT`（引数$$2$$、中置記法`<<`）
- 同値演算子`EQUIV`（引数$$2$$、中置記法`==`）
- 等号演算子`EQ`（引数$$2$$、中置記法`==`） 
- 不等号演算子（ノットイコール）`NEQ`（引数$$2$$、中置記法`!=`） 
- 不等号演算子（小なりイコール）`LEQ`（引数$$2$$、中置記法`<=`）
- 不等号演算子（大なりイコール）`GEQ` （引数$$2$$、中置記法`>=`）
- 不等号演算子（小なり）`LNEQ`（引数$$2$$、中置記法`<`）
- 不等号演算子（大なり）`GNEQ`（引数$$2$$、中置記法`>`） 

ただし中置記法`==`は通常の等号のように並列することが出来ません。本当は`TO`の中置記法に`->`を、`EQUIV`の中置記法に`<=>`を採用したいのですが、これらはC++においてオーバーロードが制限されているため、C++コンパイラでコンパイルできるようにするためにこれらを採用することが出来ませんでした。


{% assign k = k | plus: 1 %}
## {{ i }}.{{ j }}.{{ k }} その他の基本演算子

特殊な糖衣構文は持たないですが基本的な以下の演算子を使うことが出来ます：
- 高階型`(int)->bool`の演算子`NONNEG`（非負であるという関係）
- 高階型`(string)->nat`および`(ARRAY(T))->nat`の演算子`LENGTH`（長さを返す関数）
- 高階型`(string,nat)->nat`および`(ARRAY(T),nat)->T`の演算子`ENTRY`（第$$1$$引数の第$$2$$引数$$+1$$番目の成分を返す演算子）
- 高階型`(string,nat)->string`および`(ARRAY(T),nat)->ARRAY(T)`の関数`INISEG`（第$$1$$引数の始切片であって長さが第$$2$$引数であるものを返す関数）
- 高階型`(string,nat)->string`および`(ARRAY(T),nat)->ARRAY(T)`の関数`FINSEG`（第$$1$$引数の終切片であって長さが第$$2$$引数であるものを返す関数）
- 各非負整数$$i$$に対する高階型`(PROJ(T0,…,Tn))->Ti`の関数`PROJ<i>`（第$$1+i$$成分を返す関数）
- 高階型`((T0,…,Tn)->PROD(T0,…,Tn)`の関数`TUPLE`（恒等写像に対応する関数）

ただし`nat`は`int`型の変数`n`を用いて`SPEC(nat,n,NONNEG)`と定義される型で、非負整数全体の集合に対応します。

{% assign k = k | plus: 1 %}
## {{ i }}.{{ j }}.{{ k }} メタ演算子

既存の演算子から別の演算子を定義するために以下のマクロを使うことが出来ます：
- 高階型`(T)->T`の演算子`f`と`nat`型の表現`n`に対し、写像$$f^n$$に対応する高階型`(T)->T`の関数`f^n`を生成するメタ演算子`^`
- 高階型`(T1,T2)->T3`の演算子`f`と`T1`型の表現`x`に対し、写像$$y \mapsto f(x,y)$$に対応する高階型`(T2)->T3`の関数`CURRY(f,x)`を生成するメタ演算子`CURRY`
    - デフォルトの`CURRY(f,x)`は翻訳時に$$\textrm{Curry}(f,x)$$と表示されます。
    - オプション引数付きの`CURRY(f,x,EMPTY)`では翻訳時に$$fx$$と表示されます。
    - オプション引数付きの`CURRY(f,x,SUB)`では翻訳時に$$f_{x}$$と表示されます。
- 高階型`(nat)->T`の演算子`f`と`nat`型の変数`n`に対し、写像$$n \mapsto (f(i))_{i=0}^{n-1}$$に対応する高階型`(nat)->ARRAY(T)`の関数`ARRAYISE(f,n)`を生成するメタ演算子`ARRAYISE`


{% assign k = k | plus: 1 %}
## {{ i }}.{{ j }}.{{ k }} ライブラリQpBasic

`BASIC;`と書くことで、追加のライブラリである`QpBasic`に登録されている以下の演算子を使うことが出来ます：
- ハイパー演算子`Arrow`（高階型`(nat,nat,nat)->nat`）
- チェーン表記`Chain`（高階型`(nat,LDOTS)->nat`）
- N原始`N`（高階型`(string,nat,LDOTS)->nat`）


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 無視される文字列

半角空白か改行が`(`か`)`か`,`か`;`の前後どちらかに$$1$$個以上ある場合、それらは全て無視されます。連続した`;`は１つの`;`と同等に処理されます。コメントアウトされた文字列も無視されます。C++のコンパイラを使うので当然ですね。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. C++による拡張

C++コンパイラがC++のコードも許容することを逆に利用して、C++を部分的に組み込むように$$\mathbb{Q}_p$$を拡張することが出来ます。例えば$$\mathbb{Q}_p$$における`int`型の定数は`1230`のような整数の符号付き十進法表記しか許されていませんでしたが、C++のコードで定義された関数`int f(int n)`を用いて`f(567)`などとしたものも$$\mathbb{Q}_p$$の定数として使うことができます。例えば変数`x`に対する`PUT(x,f(f(32)))`等は問題なくコンパイル出来ます。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 翻訳

$$\mathbb{Q}_p$$で許容される文字列`C`と`C`に含まれる型またはDEF文の定める演算子である文字列`s`とコンマを含まない文字列`L`と`F`と`S`と`M`に対し、`int main(){C; WRITE(s,L,S,F,M); return 0;}`というコードをコンパイルして実行すると、`s`が演算子の時は標準出力に`s`の定義文の構文木を出力し、`s`が型でも演算子でもカレントディレクトリからの相対パスが`s`のファイルを`M`に対応するオープンモードで開き、`L`に対応する言語の文字列を書き込みます。
- `L`が`JAPANESE`の時、対応する言語は日本語
- `L`が`ENGLISH`の時、対応する言語は英語
- `S`が`FANDOM`の時、ファイルに書き込まれた文字列をFANDOMで出力させるとDEF文の適切な数式が表示されます。
- `S`が`JEKYLL`の時、Jekyllで出力させるとDEF文の適切な数式が表示されるようにする予定です。（未対応）
- `M`が`APP`の時、ファイルの末尾に文字列を書き加えます。
- `M`が`TRUNC`の時、ファイルを白紙化してから文字列を書き加えます。

ライブラリを導入するのが面倒という人は[管理人](https://twitter.com/non_archimedean)にコードを渡して下さればファイルに書き込まれた文字列をお返しします。


{% assign i = i | plus: 1 %}
{% assign j = 0 %}
# {{ i }}.実行

冒頭で述べましたように、$$\mathbb{Q}_p$$における演算子のDEF文を実行する機能を実装する予定は今のところないのですが、ひとまず「どのように実行されるか」は許容される文字列の分類名とそれらの定義においてカッコ書きで説明した部分を参考にして推測して下さい。大雑把な流れは、演算子のDEF文を実行する際に何らかの演算子が呼ばれる時、その演算子のDEF文を実行する、という流れです。C++による拡張を行った$$\mathbb{Q}_p$$の実行方法は、C++の関数が呼び出された箇所はC++の規格に従って実行し、そうでない箇所は通常の$$\mathbb{Q}_p$$の規格に従って実行します。

$$\mathbb{Q}_p$$における演算子のDEF文に対応する部分再帰関数の定義域は、そのDEF文の実行が正常終了するような入力全体の集合です。すなわち、それは無限ループを起こしてしまう入力および異常終了を起こしてしまう入力全体の集合の補集合となります。無限ループを起こしてしまう場合は実行時にエラーを出せません。一方で異常終了を起こしてしまった時は適切なエラーを標準出力する仕様を想定しています。例えばあえて「もし実行されたら規格に反してしまう命令行」をDEF文に仕込んでおきエラーの有無を確認することで、意図通りの処理が行われているかのデバッグが可能になります。ただしC++における例外処理と違い、そのような規格違反の処理は実行次第異常終了となります。以下に異常終了の条件を説明します。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. EXIT文

DEF文の実行においてEXIT文が実行された場合は異常終了となります。

例えば`bool`型の表現`b`に対する`IF(b,EXIT)`という命令行が型`int`のDEF文に含まれることは許容されますが、この文が実行される時に`b`が`true`として評価されることが想定されていないという意思表示になります。例えば`万が一`b`がtrue`になる場合はコードにミスがあるのでエラーを出したい時や、「`b`が`true`になるような引数は演算子の定義域に含まないことを明示したい時にそのような文を使いましょう。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 自由変数の使用

変数`x`がDEF文$$D$$の実行において最初に参照される時、実行中の命令行を`L`と置くと、以下の２条件のいずれかを満たさなければ異常終了となります：
1. `x`は$$D$$の定める演算子の引数の成分である。
1. `L`は`x`のPUT文である。

要するに引数の成分であるかPUT文を一度実行した変数しか参照してはいけません。それは未定義な変数の使用となります。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 変数の書き換え

変数`x`がDEF文$$D$$の実行において参照される時、実行中の命令行が`x`のPUT文であるならば、以下の２条件の両方を満たさなければ異常終了となります：
1. `x`は$$D$$の定める演算子の引数の成分でない。
1. これ以前に`x`は一度も参照されていない。

要するにPUT文を実行できるのは、引数の成分でない変数を最初に参照した時に限ります。それは変数の二重定義となります。例えば引数をPUT文で書き換えたり、既にPUT文を実行して束縛された変数を再度PUT文で書き換えたりしてはいけません。従って$$\mathbb{Q}_p$$における変数は一般のプログラミング言語における変数と違い、引数の成分でない限りは実質定数として振る舞うということになります。これは通常の数学における束縛変数の扱いと似せた仕様です。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. 未定義な作用素の使用

$$\Qp$$で許容される文字列`C`内のDEF文の実行において作用素`g`が参照される時、`C`が`g`のDEF文を含まなければ異常終了となります：

要するに未定義の作用素を参照してはいけません。実行中のDEF文自身が`g`のDEF文であっても良いので、自分自身を呼び出す再帰や相互再帰は可能となります。ただし無限ループの有無は判定できません。


{% assign j = j | plus: 1 %}
## {{ i }}.{{ j }}. DEF文末への到達

DEF文の実行においてDEF文末へ到達した場合は異常終了となります。

