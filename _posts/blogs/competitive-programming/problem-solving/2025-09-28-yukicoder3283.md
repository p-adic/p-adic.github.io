---
layout: blog
title: yukicoder No.3283 Labyrinth and Friendsの別解
date: 2025-09-28
excerpt: "Labyrinth and Friendsの別解です。"
parent: competitive-programming-problem-solving
prev-child: yukicoder3257
next-child: 
blog: true
problem_url: https://yukicoder.me/problems/no/3283
image-directory: 
tags: [競技プログラミング,数学]
---

今回扱うのは<a href="{{ page.problem_url }}">yukicoder contest 484 E問題 No.3283 Labyrinth and Friends</a>です。[公式解説]({{ page.problem_url }}/editorial)に載っていない別解を紹介します。


## 問題の概要

正確な問題文は[こちら]({{ page.problem_url }})です。

> $N$頂点根付き木$T$の各頂点$v$に非負整数値価値$s_v$が、各辺$e$に非負整数値コスト$c_e$が定義されている。根を含み価値の総和が$X$以上となる連結誘導部分グラフのコストの総和の最小値を求めよ。


## 前置き

公式解説で扱われている解法は二乗の木DPと呼ばれるテクニックの亜種のようですが、[二乗の木DPは少なくともここ3年以内に★3以下でyukicoderで要求されたことがなく](https://p-adic.github.io/yukicoder-difficulty-statistics/#二乗の木DP)（集計を間違っていたらすみません）、主に★3以下までしかupsolveしていない筆者（[$p$進大好きbot](https://x.com/non_archimedean)）は二乗の木DPを名前しか聞いたことがありませんでした。

となるとこの問題の難易度（★2.5）が主戦場の他の参加者も知らない可能性があると思ったので、二乗の木DPを一切使わない解法を紹介すると役に立つかもしれないと思い、深さ優先探索を用いた[ナップサックDP](https://p-adic.github.io/yukicoder-difficulty-statistics/#ナップサックDP)を紹介します。


## 解説

まず根付き木などの有向非輪状グラフ（DAG）で何かを計算する問題は、線形グラフの場合に絞って考察をし、それを一般化できるかを考えると良いです。

今回は線形グラフだと始切片（一般の部分集合ではなく始端を端点とする区間）のみ選択可能なナップサック問題となり、$\textrm{dp}[v][x]$に「頂点$v$を選択する場合に価値$x$以上を実現するコストの最小値」を格納していくナップサックDPで$\Theta(NX)$で処理することが可能です。（実装上は$x < X$において「価値$x$以上」を「価値$x$」に置き換えても構いません）

同様のナップサックDPを一般の根付き木に拡張できるか考えてみると、漸化式にやや修正が必要でもう$1$パラメータ増やし$\textrm{dp}[i][v][x]$に「深さ優先探索順で$i$番目までの頂点に制限して得られる誘導部分グラフである木$T_i$に$T$を置き換えて同じ問題を考えた時、頂点$v$を選択する場合に価値$x$以上を実現するコストの下限」を格納していく動的計画法が可能であることが分かります。具体的には深さ優先探索順でちょうど$i$番目の頂点を$v_i$と置いた時、

1. $i = 1$ならば$\textrm{dp}[i][v][x]$は
    1. $v = v_i$（つまり$T$自身の根）かつ$x = 0$ならば$0$と定める。
    1. そうでないならば$\infty$と定める。
1. $i > 1$ならば$\textrm{dp}[i][v][x]$は
    1. $v = v_i$ならば$T$における$v$の親を$p$として、$\textrm{dp}[i-1][v][x]$と$\textrm{dp}[i-1][p]$から線形グラフのナップサックDPと同様の漸化式で定める。つまり以下のように処理する。
        1. $x \geq s_p$ならば$\min(\textrm{dp}[i-1][v][x],\textrm{dp}[i-1][p][x-s_p]+c_{p \to v})$と定める。
        1. $x < s_p$ならば$\textrm{dp}[i-1][v][x]$と定める。
    1. $v \neq v_i$ならば$v_i$を$T_i$の根とした時の$T_i$における$v$の親を$p$として$\min(\textrm{dp}[i-1][v][x],\textrm{dp}[i][p][x])$と定める。

とすれば良いです。しかしながら$1$パラメータ増えた分DP配列の更新が大変になり、愚直に処理すると最悪計算量が$\Theta(N^2X)$となってしまいます。この解法の高速化を考えましょう。

$i$がインクリメントされた際に計算が必要なDP配列の成分（全部$\infty$であることが確定するわけではない成分）は、$T_i$の各頂点$v$と$X$以下の各非負整数$x$に対する$\textrm{dp}[i][v][x]$です。しかし、その全てを計算する必要はありません。何故なら、DP配列に$1$パラメータ$i$を追加した理由を考えると（つまり上述した計算手順を見ると）$\textrm{dp}[i][v]$の成分が参照されるのは

1. $i = N$で$v = v_1$（つまり$T$の根）であり最終的な答えを計算する時。
1. $i < N$で$T$において$v$が$v_{i+1}$の親ノードであり$\textrm{dp}[i+1][v_{i+1}]$の成分を計算する時。
1. $T_i$における$v$の子ノード$c$に対する$\textrm{dp}[i][c]$の成分を計算する時。

の$3$回だけだからです。

分かりやすい例として、$v$が$T$の葉である時、$\textrm{dp}[i][v][x]$は$v = v_i$の時しか参照されません。そして参照されない値を計算する必要はなく、計算する必要がない値を計算する時にしか参照されない値も計算する必要はありません。

しかも$i$が増えていくと、現時点の$i$より$2$以上小さい$i$に対する$\textrm{dp}[i][v][x]$は不要になるので、それらのデータは保持し続ける必要がありません。つまり、考察の仮定で増やした$1$パラメータ$i$を削除して（[inplace化](https://p-adic.github.io/yukicoder-difficulty-statistics/#inplace DP)して）$\textrm{dp}[v][x]$として管理すれば良いです。

というわけで実際に必要な値のみをinplaceで計算することにすると、結局次のような手順で計算していけば良いことが分かります。

1. $\textrm{dp}[v_1]$を$(0,\infty,\ldots)$と定める。
1. 深さ優先探索を行い、
    1. 頂点$v$から子ノード$c$に進む時は$\textrm{dp}[c]$を$\textrm{dp}[v]$から線形グラフのナップサックDPと同様の漸化式で定める。
    1. 子ノード$c$から頂点$v$に戻る際は$\textrm{dp}[v]$を$\textrm{dp}[c]$で成分ごとにchange min更新する。

これは単純な再帰で実装可能です。この解法の計算量は想定している実装において$\Theta(NX)$です。


## 実装例

- c++: [https://yukicoder.me/submissions/1123329](https://yukicoder.me/submissions/1123329)


## 自分用覚え書き

github pagesで数式を使う際は、閉じカッコと半角アンダーバーの間に半角スラッシュを入れないとmarkdownからhtmlへの翻訳の仕様でバグるらしい。

数式環境をくくる大括弧と数式環境内の中括弧や半角空白や濃度のシャープは半角スラッシュ２つ、改行は半角スラッシュ５つ、その他は基本的に半角スラッシュ１つで良さそう。htmlとmathjaxの関係が難しい。

inline数式内の縦棒はlvertなどを使わないとmarkdownの表と認識される。

arrayとalignはどちらも使える。arrayが使えない気がしてしまったのは中括弧につける半角スラッシュの個数を間違えていたから。alignはアンパサンドを等号の右側につけて半角空白を２つ入れると幅がちょうど良さそう。arrayなしだとアンパサンドは使えない。
