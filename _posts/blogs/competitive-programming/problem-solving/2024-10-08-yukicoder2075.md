---
layout: blog
title: yukicoder No.2075 GCD Subsequence解説の解説
date: 2024-10-08
excerpt: "GCD Subsequenceの解説の解説です。"
parent: competitive-programming-problem-solving/
prev-child: AHC036/
next-child: 
blog: true
problem_url: https://yukicoder.me/problems/no/2125
image-directory: 
tags: [競技プログラミング,数学]
---

今回扱うのは[yukicoder contest 360 F問題 No.2075 GCD Subsequence]({{ page.problem_url }})です。[公式解説]({{ page.problem_url }}/editorial)は恐らくゼータ変換について熟知している人向けに書かれているためゼータ変換絡みのキーワードが一切使われておらず、ゼータ変換を知らない人が読んだ時にどうしてこのような解法が思いつくのか分からないかもしれません。というわけでゼータ変換の言葉をきちんと使って検索しやすいようにまとめてみました。


## 問題の概要

正確な問題文は[こちら]({{ page.problem_url }})です。色々すっ飛ばして解説を理解するためのエッセンスだけを抽出すると以下のような問題になります。

> 正整数$M,Q$と長さ$N$の整数列$B = (B_j)_{j=1}^{M} = (B_1,B_2,\ldots,B_M)$が与えられます。
> 以下で説明する$Q$個のクエリを与えられた順に処理してください。
> 
> 各クエリは$M$以下の正整数$j$と整数$x$の組$(j,x)$として与えられます。
> クエリ$(j,x)$を処理するには、まず$B_j$を$x$で置き換えることで$B$を更新し、その後
> 
> \\[
> \sum_{\textrm{gcd}(j,k) = 1} B_k
> \\]
>
> を求めてください。

元の問題文の原型を留めていませんが、$B$は公式解説で言うところの$\textrm{dp}$で、$Q$は$N$で、$j$は$A_i$です。


## 解法

要求されているのは$B$の一点更新と、$\textrm{gcd}(j,k) = 1$となる$k$をわたる$B_k$の総和取得です。後者が見慣れない操作ですが、実はこれは倍数ゼータ変換と（その逆変換である倍数メビウス変換ではなく）約数メビウス変換の組み合わせで高速に処理できます。

ゼータ変換とメビウス変換が何かについては説明しないので、それらを知らない場合は調べてみましょう。この記事の目的はあくまで、検索しやすいキーワードを散りばめて解説の翻訳をすることです。

$M$以下の各正整数$m$に対し$C_m := \sum_{\textrm{gcd}(j,k) = m} B_k$と定めると、求める値$\sum_{\textrm{gcd}(j,k) = 1} B_k$は$C_1$に他なりません。

整数列$(C_m)_{m=1}^{M}$を$C$と置きます。$B$と$C$の倍数ゼータ変換をそれぞれ$\zeta_{\textrm{mul}} * B = ((\zeta_{\textrm{mul}} * B)_m)_{m=1}^{M}$と$\zeta_{\textrm{mul}} * C = ((\zeta_{\textrm{mul}} * C)_m)_{m=1}^{M}$と置きます。ちなみに掛け算の記号で書いているのは、隣接代数を用いたゼータ変換の定義が実際に畳み込みで与えられるからです。

$M$以下の任意の正整数$m$に対し、倍数ゼータ変換の定義から

\\[
(\zeta_{\textrm{mul}} * C)_m = 
\left\{
\begin{array}{ll}
(\zeta_{\textrm{mul}} * B)_m & (m \mid j) \\\\\
0 & (\textrm{otherwise})
\end{array}.
\\]

となります。何故なら、$m$が$j$の約数である時、対応$k \mapsto \textrm{gcd}(j,k)$により$m$の倍数$k$全体の集合の自己写像が定まる（その写像による終域の各点の逆像を考えることで定義域が排他的に分解される）からです。

従って$\zeta_{\textrm{mul}} * B$と$\zeta_{\textrm{mul}} * g$の約数メビウス変換をそれぞれ$\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * B = ((\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * B)_m)_{m=1}^{M}$と$\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * C = ((\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * C)_m)_{m=1}^{M}$と置くと、

\\[
(\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * B)_j = (\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * C)_j
\\]

が成り立ちます。何故なら、約数メビウス変換の$j$での値は$j$の約数$m$における値のみから定まるからです。

更に$\zeta_{\textrm{mul}} * C$の倍数メビウス変換を$\mu_{\textrm{mul}} * \zeta_{\textrm{mul}} * C = ((\mu_{\textrm{mul}} * \zeta_{\textrm{mul}} * C)_m)_{m=1}^{M}$と置くと、メビウスの反転公式から倍数メビウス変換は倍数ゼータ変換の逆変換なので

\\[
\mu_{\textrm{mul}} * \zeta_{\textrm{mul}} * C = C
\\]

が成り立ちます。特に$(\mu_{\textrm{mul}} * \zeta_{\textrm{mul}} * C)_1 = C_1$です。

そして倍数メビウス変換と約数メビウス変換の定義から、

\\[
C_1 = (\mu_{\textrm{mul}} * \zeta_{\textrm{mul}} * C)_1 = \sum_{1 \mid m} \mu(m) (\zeta_{\textrm{mul}} * C)_m = \sum_{m=1}^{M} \mu(m) (\zeta_{\textrm{mul}} * C)_m = \sum_{m | j} \mu(m) (\zeta_{\textrm{mul}} * C)_m = (\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * C)_j = (\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * B)_j
\\]

となります。以上より、$(\mu_{\textrm{div}} * \zeta_{\textrm{mul}} * B)_j$を計算すれば良いことが分かりました。これが解法で説明されていることです。


## 余談

半順序集合$P$と（単位的でなくても良い）$\mathbb{Z}$代数$R$が与えられている時、隣接代数の一般論として$P$上の$R$値関数に対するゼータ変換とメビウス変換が定義されます。倍数関係を用いている時が倍数ゼータ変換と倍数メビウス変換、その逆向きの半順序である約数関係を用いている時が約数ゼータ変換と約数メビウス変換です。

ただし全体加算や一点取得を行わない場合は$R$への$\mathbb{Z}$作用を用いないので、$R$をただの（単位的でなくても良い）環としても良いです。環と$\mathbb{Z}$代数は代数的に等価ですが、計算量込みでは等価ではないことにご注意ください。

同様に全体乗算や（$P$の順序がjoin半束である場合の）畳み込み乗算を行わないならば積構造は不要なので、$R$を単なる$\mathbb{Z}$加群としても良いです。代数的には可換群と等価ですね。

ここで半順序集合$P'$と写像$f \colon P \to P'$と部分写像$g \colon P' \to P$と写像$r \colon P' \to 2^{P'}$と$s \in P'$が以下の条件を満たすとします：

1. $g$は定義域に$r(s) \in 2^{P'}$を含む。
1. $P'$の順序に関して、$s$は$r(s)$の最大元である。
1. $g(s)$を上界に持つ$P$の要素全体の集合を$R_s$と置き、$f$の$R_s$への制限を$f_s$と置くと、$f_s$は順序保存写像$R_s \to r(s)$である。
1. $P$の順序に関して、$r(s)$の任意の要素$s'$に対し$g(s')$が逆像$f_s^{-1}(s')$の最大元である。（従って特に$f_s$は$r(s)$への全射である）

例えば$P$と$P'$が$M$以下の正整数の倍数関係で与えられる半順序集合で、$f(t)$が$\textrm{gcd}(j,t)$と定められており、$g$が恒等写像であり、$r$は約数全体の集合を返す写像であり、$s = 1$である時、条件を満たします。

$R$が$\mathbb{Z}$であり、$P$上の$R$値関数$F$が$B$で与えられる時、$f(t)=s$を満たす$R_s$の要素$t$全体を渡る$F(t)$の総和はまさに$C_1$に他なりません。

より一般に、$P',f,g,r,s$が上の条件を満たしさえすれば、$\zeta_{\textrm{mul}} * B$から$C_1$を求めた要領で、$P$上の$R$値関数$F$のゼータ変換から$f(t)=s$を満たす$R_s$の要素$t$全体を渡る$F(t)$の総和取得が可能です。

そのような操作に対応した抽象ゼータ変換ライブラリーの実装例は[こちら](https://github.com/p-adic/cpp/tree/master/Mathematics/Combinatorial/ZetaTransform)です。
